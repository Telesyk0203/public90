# Це коментар
number = 3 #Змінній number було присвоєно значення 3м
print ('The value of the varuable number is ', number) 
#name=  input ('What is your name?')  
message= 'Hi everyone, how are you?'
#len(message) 
print('the message have', len(message), 'letters')
# Коли нам потрібно перетворити ціле число в одному рядку коду в рядок, ми використовуємо функцію "str()". Наприклад:
number= str(123)
print(number)
#Таким чином, немає жодної різниці між записом "str(123)" та записом "123".
#int() Ця функція робить щось подібне. Вона перетворює переданий їй рядок у ціле число.
newNumber = int('234')
print(newNumber)
##############float()###############
#Як Ви могли здогадатися, ця функція перетворює рядок у форму з плаваючою комою.
number = float('123.4')
print(number)
# оператори використовуються для математичних операцій, таких як додавання, віднімання, множення, ділення тощо.
x = 15
y = 4
# Output: x + y = 19
print('x + y =',x+y)
# Output: x - y = 11
print('x - y =',x-y)

# Output: x * y = 60
print('x * y =',x*y)

# Output: x / y = 3.75
print('x / y =',x/y)

# Output: x // y = 3
print('x // y =',x//y)

# Output: x ** y = 50625
print('x ** y =',x**y)
# "Логічними операторами" є: and, or, та not.
x = True
y = False
# Output: x and y is False
print('x and y', x and y)
# Output: x or y is True
print('x or y is',x or y)
# Output: not x is False
print('not x is',not x)
# "Оператори порівняння", як випливає з їх назви, використовуються для порівняння значень; вони оцінюють, чи є твердження істинним або хибним.
x = 10
y = 12

# Output: x > y is False
print('x > y  is',x>y)

# Output: x == y is True
print('x == y  is',x==y)

# Output: x >= y is True
print('x >= y is',x>=y)

#"Оператори присвоювання" використовуються для присвоєння значень змінним. Ми вже знайомі з найпростішим оператором: x=5, де значення 5 присвоюється змінній x.

#Існують також різні складні оператори, наприклад, а+=5, що додає значення 5 до значення змінної a, і потім це нове значення присвоюється змінній a. Тобто він еквівалентний виразу a=a+5.

#Часто нам потрібно, щоб програма щось робила, але лише тоді, коли щось інше є істинним або хибним. У таких випадках ми використовуємо оператор if.
#Тепер давайте подивимося, для чого використовується оператор else. Якщо твердження if не виконується, весь код оператора if ігнорується і виконується лише тіло оператора else. Таким чином, після ключового слова "else" ми задаємо код, який виконується лише в тому випадку, якщо умова if не була виконана.
if (7<6):
    print('This is true')
else:
    print('7 more than 6')

#У прикладі, де ми використовуємо індивідуальні оператори if, кожна умова перевіряється незалежно від того, чи це потрібно. Наприклад, якщо значення змінної становить 96, програма виведе "Відмінно", але продовжить перевіряти умови для 9, 8, 7..., що не дуже ефективно. Проте, використовуючи "оператор elif", програма припиняє перевіряти всі інші умови в блоці, як тільки одна з умов буде виконана.
points= eval(input('Введіть кількість балів:'))

if points>=90:
    print('Відмінно')
elif points>=80:
    print('Добре') 
elif points>=70:
    print('Непогано')
elif points>=60:
    print('Задовільно')
else :
    print('Незадовільно')
#Функція eval дозволяє програмі python запускати код python у собі. Додайте будь який вираз для перевірки 
a= input("Введіть вираз що хочете поррахувати:  ")
print (eval(a))

# Петля for Коли програма запускається, вона встановлює змінну i як 0. При кожному поверненні до початку циклу, змінна i збільшується на 1. Так повторюється 10 разів і кожного разу змінна збільшується на 1, поки цикл не здійснить 10 ітерацій. У цей момент змінна має значення 9.
for j in range(10):
    print('God!Please Stop war !!!')
#Ця програма просить користувача ввести число, після чого виводить квадрат цього числа та повторює процес тричі:
for k in range(3):
    number= eval(input('Enter number:'))
    print('Квадрат вашого числа це', number**2)
#Функція range 
#Значення, яке ми записуємо у функцію range, визначає, скільки разів цикл повториться. Функція range працює наступним чином: вона генерує послідовність чисел, від нуля до числа, введеного нами у функцію мінус один. Отже, range(5) генерує таку послідовність: 0, 1, 2, 3, i 4.

#Якщо нам потрібно, щоб список чисел починався зі значення, відмінного від нуля, ми можемо досягти цього, вказавши це число в функції "range"
#Інший варіант полягає в тому, що список збільшується не на 1, а на інше обране нами число. Розглянемо такий приклад:
#           range(1,5) згенерує список 1, 2, 3, 4.
#За допомогою команди range(1, 10, 2) буде створено список "1, 3, 5, 7, 9". Як можна здогадатися, список починається з числа 1 (перший параметр) і доходить до числа 10 (другий параметр), причому кожне значення збільшується на 2 (третій параметр).
#Структура циклу
                #for variable_name in range(кількість_повторів):
                #команди, які потрібно повторити
for j in range(166000,169500,500):
    print(j,'Вбитих москалів!!!)')
#бувають ситуації, коли ми не знаємо заздалегідь, скільки ітерацій буде виконано. У цих ситуаціях використовувати лічильник циклу немає сенсу, оскільки умова виходу з циклу залежить не від значення лічильника, а від іншої умови. Цикл while створено саме для таких типів ситуацій.
                        #while умова:
                        #тіло циклу while
# Приклад друку чисел від 1 до 10:
a=0
while a<10:
    print(a)
    a=a+1
    
# Що насправді тут відбулось? Спочатку змінна "a" має значення 0. Після входу в цикл while (коли a менше 10) це значення збільшується на 1 та виводиться на екран. Це продовжується, поки "a" не досягне 10.

############Break#########
#"Оператор break" використовується для завершення циклів "for" або "while" до їхнього закінчення.
#Ця програма дозволяє користувачеві ввести 10 чисел. Однак користувач може достроково її припинити, ввівши від'ємне число:
for k in range(3):
    num = eval(input('Треба ввести число :'))
    if num < 0:
        break

for val in "string":
    if val == "i":
        break
    print(val)
#У цьому прикладі "цикл for" перевіряє літеру за літерою. Він починає з "s" і перевіряє, чи одна з них "i". Якщо це не так, літера виводиться ("друкується"). Після потрапляння на букву "i" команда "break" перериває "цикл for", і тому виводяться лише букви перед "i": s, t, r.

#####################Continue##############
#"Оператор continue" негайно переходить до наступної ітерації циклу та припиняє виконання поточної ітерації.
for val in "string":
    if val == "i":
        continue
    print(val)

#Як можна бачити, у цьому прикладі на відміну від попереднього, коли ми дійшли до літери "i", цикл for не зупинився, а продовжував друкувати слово до кінця без цієї літери. Це єдина різниця між операторами "break" та "continue".

# Функції використовуються для розбиття великих програм на менші частини, роблячи програму більш читабельною. Вони також стануть у нагоді, коли нам доведеться повторювати один і той же код у різних частинах нашої програми. Ми можемо помістити повторюваний код у функцію і викликати її щоразу, коли потрібно виконати команди з цього коду. Функції також можна використовувати для створення допоміжних функцій, математичних функцій тощо.

#Функції визначаються за допомогою ключового слова "def". Команда закінчується двокрапкою і в наступному рядку записується код, який є частиною функції.

def print_word():
    print('Доброго вечора ми з України !')
print_word() 
# Наша функція з попереднього прикладу не мала аргументів (дужки після імені функції були порожніми). Тепер у нас аналогічна функція з одним аргументом:
def print_word(n):
    print('Доброго вечора ми з України !!! Вам пізда москалі!!!'*n)
    print()
print_word(5)
#Значення, яке ми присвоюємо змінній "n", показує, скільки разів буде написано 'Доброго вечора ми з України !!! Вам пізда москалі!!!'

#Ми можемо одночасно передати функції декілька аргументів.

def write(string, b ):
    print(string*b)
    print()

write ("Свинособаки!!!" , 6)

#Як виглядають функції, що проводять розрахунки та повертають відповідний результат? Ознайомтесь з прикладом простої програми, яка перетворює метри в сантиметри:
def convert(m):
    return m*100
    
convert(2)
#Аргументи функції можуть мати значення за замовчуванням. Це значення є необов’язковим, тому, якщо інше значення не буде присвоєно такому аргументу при виклику функції, код функції буде використовувати значення за замовчуванням. Наприклад:
def print_func(string, n=2):
	print (string * n)
	print()
print_func('rerer!!!', 5)
#Отже, якщо ми не задамо другий аргумент, дане слово буде написано двічі, оскільки ми вказали це при визначенні функції.

#          def fancy_print(text, color, background, style, justify):

#Кожного разу, коли ми викликаємо цю функцію (зараз нам не дуже важливо, що вона робить, ми просто розглядаємо сигнатуру функції), нам потрібно знати правильний порядок аргументів. Так, ми спочатку задамо текстове значення, потім колір, фон, стиль та вирівнювання. Однак Python дозволяє нам іменувати аргументи при виклику функції, як показано у наступних прикладах:

# fancy_print(text='Hi', color='yellow', background='black', #style='bold', justify='left')

#fancy_print(text='Hi', style='bold', justify='left',background='black', color='yellow'

#Порядок аргументів у цьому випадку не важливий, оскільки ми використовуємо іменовані аргументи (імена аргументів).
#При визначенні функції рекомендується призначати аргументам значення за замовчуванням.

# Область видимості змінної представляє собою блок коду, в якому певна змінна "існує", тобто до неї можна отримати доступ та змінити її значення виключно в цьому блоці. Поза цим блоком змінної не існує. 

#################### Локальні змінні#########################
#Припустимо, що у нас є дві функції і вони обидві мають змінну "i":
def func1():
    for i in range(10):
        print(i)

def func2():
    i=100
    func1()
    print(i)
#Проблема, яка може виникнути тут, полягає в тому, що при виклику функції "func1" ми можемо змішати значення змінної з цієї функції зі значенням змінної з "func2". У великих програмах важко уважно слідкувати за тим, чи використовували ми ім'я змінної в інших функціях. На щастя, нам не потрібно про це турбуватися в Python.

        #Коли змінна визначається у функції, вона стає локальною змінною.
# Це означає, що вона існує лише для функції, в якій визначена, але не виходить за межі її області видимості.

###################Глобальні змінні#####################

#Ми використовуємо глобальні змінні у випадку, якщо нам потрібно використовувати одну і ту ж змінну в декількох функціях. У наступному прикладі показана можливість такого використання:
def reset():
    global time_left
    time_left=0

def print_time():
    print(time_left)

time_left=30

#Тут ми можемо бачити тільки те, що ми визначили змінну "time_left" у функції reset, і що ми також використали її в функції "print_time()". Якщо функція хоче змінити значення змінної time_left, то нам необхідно вказати, що зміннa time_left є "глобальною" всередині функції, в якій ми визначаємо змінну: для цього використовується команда "global". Проте, якщо ми хочемо використовувати глобальну змінну, але не хочемо змінювати її значення, нам не потрібна команда global.

#Базові концепції - для чого потрібні списки?

# Ми вже знаємо про рішення Python, які можуть стати заміною виснажливим завданням, і ми продовжимо наше навчання в тому ж напрямку.

#Припустимо, нам потрібно взяти 30 чисел і зробити щось з ними, наприклад, відсортувати їх у напрямку зростання чи спадання. Ми могли б створити тридцять змінних: number1, number2 ... number30, але це трудомістка процедура, особливо при більшій кількості змінних, які потрібно ввести. Списки є рішенням такої проблеми.

#Списки створюються дуже просто: квадратні дужки використовуються для позначення початку та кінця списку, а коми відокремлюють дані у списку:
L=[3,4,5]
# Аналогічно тому, як 0 використовується при роботі з числами, коли інше число не задано, або тому, як використовується порожній рядок '' при роботі з рядками, у випадку зі списками використовується символ [] для порожнього списку.
# Символом для порожнього списку є [], аналогічно числу 0 або порожньому рядку.

#Введення списку
#Якщо нам потрібно попросити користувача ввести список, ми використаємо функцію eval(input()):
L=eval(input('Введіть список, будь ласка:'))
print('Перший елемент з цього списку', L[0])

#Друк всього списку 
#Друк всього списку здійснюється за допомогою функції print:
L=[1,2,3]
print(L)

#Список може містити будь-які дані, навіть інші списки: [1, 2.718, 'abc', [5,6,7]]

#Також ми можемо створити список з елементами, заданими в певному діапазоні. Приклад:
L=list(range(101,115))
print(L)
# len - Returns the length  of the list (the number of items)
# sum - Returns the sum of data in the list
# min - Returns the smallest item in the list 
# max - Returns the largest item in the list
L=list(range(10,115,5))
print(sum(L))

##################String як особливий вид списків######################

#Ви дізналися, що таке рядки та списки. Ми розширимо Ваші знання про списки, порівнявши їх із рядками.
#Кілька речей працюють однаково для списків та рядків.
#Ми вже знайомі з функцією len(). Ця функція також повертає довжину списку.
L = [3,4,5,7,22,43]
print(len(L))#В результаті отримуємо 6.
#Індексація та сегментація працюють так само, як і випадку з рядками. Наприклад: L[0] повертає перший елемент списку, а L[:3] повертає перші три елементи.

# Оператори + та * використовуються так само, як і у випадку з рядками. Оператор + додає один список до кінця іншого списку, а * повторює цей список певну кількість разів.
# Statement         Result
# [1,2]+[3,4,5] --> [1,2,3,4,5]
# [6,7]*3       --> [6,7,6,7,6,7]
# [0]*4         --> [0,0,0,0]

A=[2,4,6,8]
B=[1,3,5,7]
print(A+B)
[2, 4, 6, 8, 1, 3, 5, 7]
print (A[:2])# Вивести перших два елементи списку А
# Цикл for особливо стане у нагоді при роботі зі списками; він працює так само, як і з рядками. Дані друкуються один за одним, кожен в окремому рядку:
L=[2, 4, 6, 8, 1, 3, 5, 7]
for i in range(len(L)):
    print(L[i])

###################Методи списків######################

# У Python є методи роботи зі списками, які можна з легкістю використовувати, коли нам потрібно виконати певні завдання без написання функцій з нуля.

# Операції над об'єктами визначаються у функціях, які називаються "об'єктними методами". Методи – це дії, які виконуються над елементами.

# У таблиці нижче наведені деякі методи, які найчастіше використовуються при роботі зі списками:

# append(x) - Adds element x to the end of the list
# sort()    - Sorts elements of a list
# count(x)  - Returns occurences of element x in a list
# index(x)  - Returns smallest index of element in list
# reverse() - Rerevers a list (switches the order of elements in list)
# remove(x) - Removes first occurence of element x from the list
# pop()     - Remove element whith index p and restores its value
#insert(p,x)- Inserts element x to the position p on the list 
L= [39,3,45,6,7,2,90,101,43,15]
L.sort()#Сортування списку по зростанню
print() 
#[2, 3, 6, 7, 15, 39, 43, 45, 90, 101]
L.append(99) #Додати в кінець списку число 99
print(L)
#[2, 3, 6, 7, 15, 39, 43, 45, 90, 101, 99]

#Між методами списків та методами рядків є одна велика відмінність. Методи рядків не змінюють вихідний рядок, тоді як методи списку змінюють його.

#Методи рядків працюють з рядками, а методи списків – зі списками.  

# Для сортування списку L пишемо L.sort(), а не L=L.sort(). Другий вираз не працюватиме.

#            Incorrect              Correct
#String      s.replace('X','x')     s=s.replace('X','x')
#List        L=L.sort()             L.sort()

#Якщо Ви введете help(список) в оболонці Python, Ви отримаєте доступ до документів щодо інших методів списків.

L=eval(input('Створіть список, будь ласка :')) # Створити список 
print(L) #Надрукувати список 
L.reverse()# Список у зворотному порядку 
print(L) #Надрукувати список1
L.insert(2,100)# Вставити 100 на 2-ий індекс
L.append(101) # Вставити 101 в кінець списку
print(L) #Надрукувати список
print(len(L)) #Надрукувати загальну кількість даних

#####################Двовимірні списки##################

#На практиці елементи часто потрібно зберігати у вигляді таблиць. Ці таблиці називаються "двовимірними списками" або "матрицями". Один із способів їх створення – це створення списку, елементами якого є також списки. Пояснимо на наступному прикладі:
L=[[1,2,3],
   [4,5,6],
   [7,8,9]]
#Цього разу ми використовуємо два індекси для доступу до елементів списку. Наприклад, якщо нам потрібно повернути число 6, ми досягаємо цього за допомогою виразу: L[1][2].

#Для отримання інформації з рядка "r" та стовпця "c" ми використовуємо наступний вираз: L[r][c]. Спочатку вводимо порядковий номер рядка, потім номер стовпця. Відлік починається з 0.

#         0       1         2       3
#0      [0][0]  [0][1]   [0][2]   [0][3]
#1      [1][0]  [1][1]   [1][2]   [1][3]
#2      [2][0]  [2][1]   [2][2]   [2][3]
#3      [3][0]  [3][1]   [3][2]   [3][3]

# Друк двовимірних списків

# Двовимірні списки можна надрукувати за допомогою вкладених циклів "for". Це означає, що один цикл "for" міститься всередині іншого циклу. Пояснимо на наступному прикладі:
for r in range(3):
    for c in range(3):
        print(L[r][c],end="")
    print()

# Використано два цикли "for": один для горизонтального напрямку, а інший - для вертикального. Параметр end=’ ‘ функції print дозволяє виводити кілька елементів в одному рядку. По закінченню друку одного рядку за допомогою оператора print(), ми переходимо до іншого рядка.

#Ось як виглядатиме наша надрукована матриця:
                    # 123
                    # 456
                    # 789

############# Підрахунок елементів матриці###############
# Вкладений цикл for також використовується для підрахунку елементів:
count=0 
for r in range(3):
    for c in range(3):
        count=count+1
print(count)

count=0 
for r in range(3):
    for c in range(3):
	    if(L[r][c]%2==0):
	      count=count+1
print(count)
#4

################################# Файли і шлях до файлів##########################

 ################################ Читання з файлу###########################
 # Нам потрібно завантажити вміст файлу в програму. Це можна зробити двома способами.

#Перший спосіб – прочитати текстовий файл за допомогою методу побудови списків. Так, ми можемо читати текст у файлі рядок за рядком:
lines =  [line.strip() for line in open('D:\git\public90\python\campster\example.txt')]
print(lines)

#Метод strip видаляє всі символи пробілу на початку та в кінці рядка.
str='     hello everybody    '
print (str.strip())
'hello everybody'
#Якщо нам потрібно видалити символи пробілу лише з кінця рядка, тоді використовується метод rstrip.

#Другий спосіб прочитати файл – це завантажити весь файл та записати його вміст у рядкову змінну: 
s=open('D:\git\public90\python\campster\example.txt').read()
                    #\n є символом нового рядка.

####################Записування у файл############################
 
 # Існує декілька способів запису даних у файл і один із них ми розберемо прямо зараз. Припустимо, нам потрібно записати дані у файл під назвою "writing.txt".
f= open('D:\git\public90\python\campster\writing.txt', 'w')
#print(f)
print('This is line 1.', file=f)
print('This is line 2.', file=f)
f.close()
#Спочатку нам необхідно відкрити файл, що ми зробили в першому рядку коду. У цьому рядку Python створює об’єкт файлу, який ми назвали "f" (згодом ми скористаємось ним при виклику відкритого файлу). Створивши текстовий файл " writing.txt", ми додали мітку "w", яка означає, що ми хочемо щось записати у файл.

#За допомогою цього рядка коду ми створили файл "writing.txt", який все ще порожній та знаходиться у тому ж каталозі, що й програма.

#Щоб щось записати в новий файл "writing.txt", ми використовуємо команду print з необов'язковим аргументом file, що посилається на файл, в який ми хочемо ввести текст. Файл "f" посилається на "writing.txt".

#Так, якщо файл з таким іменем вже існує, весь раніше введений вміст буде видалений та будуть внесені нові дані.

#Якщо файл "writing.txt" вже існує, нові введені дані замінять існуючий текст.

# Можливі режими відкриття файлів та їх значення:

# r: Відкриває файл лише для читання. Це режим за замовчуванням. Вказівник знаходиться на початку файлу.
f= open('D:\git\public90\python\campster\writing.txt', 'r')
# rb: Відкриває файл для читання у двійковому режимі. Це режим за замовчуванням. Вказівник знаходиться на початку файлу.
f= open('D:\git\public90\python\campster\writing.txt', 'rb')
# r+: Відкриває файл для читання та запису. Вказівник знаходиться на початку файлу.
f= open('D:\git\public90\python\campster\writing.txt', 'r+')
# rb+: Відкриває файл для читання та запису у двійковому форматі. Вказівник знаходиться на початку файлу.
# w: Відкриває файл лише для запису. Він перезаписує файл, якщо останній уже існує. Якщо файл не існує, створюється новий файл для запису.
f= open('D:\git\public90\python\campster\writing.txt', 'w')
# wb: Відкриває файл для запису лише у двійковому форматі.
#  Він перезаписує файл, якщо останній уже існує. Якщо файл не існує, створюється новий файл для запису.
f= open('D:\git\public90\python\campster\writing.txt', 'wb')
# w+: Відкриває файл для запису та читання. Він перезаписує файл, якщо останній уже існує. Якщо файл не існує, створюється новий файл для запису та читання.
f= open('D:\git\public90\python\campster\writing.txt', 'w+')
# wb+: Відкриває файл для запису та читання у двійковому форматі. Він перезаписує файл, якщо останній уже існує. Якщо файл не існує, створюється новий файл для запису та читання.
# a: Відкриває файл для додавання запису. Вказівник знаходиться в кінці файлу, якщо останній існує. Якщо файл не існує, створюється новий файл для запису.
# ab: Відкриває файл для додавання запису у двійковому форматі. Вказівник знаходиться в кінці файлу, якщо останній існує. Якщо файл не існує, створюється новий файл для запису.
# a+: Відкриває файл для додавання запису та читання. Вказівник знаходиться в кінці файлу, якщо останній існує. Якщо файл не існує, створюється новий файл для читання та запису.
# ab+: Відкриває файл для додавання запису та читання у двійковому форматі. Вказівник знаходиться в кінці файлу, якщо останній існує. Якщо файл не існує, створюється новий файл для читання та запису.


##################### Копіювання файлів і директорій ######################################

# На попередніх уроках ми дізналися, як читати та записувати у файл. Тепер ми ознайомимося з деякими іншими перевагами, які може запропонувати Python. Одного дня Вам може бути доручено переглянути десятки чи сотні файлів, які Вам буде необхідно копіювати, перейменовувати, змінювати їх формат, робити копії у певному форматі тощо. Нічого цього не потрібно робити вручну, оскільки Python автоматизує цей процес з нульовою ймовірністю помилок та максимальною ефективністю в часі.

# Модуль shutil містить параметри, які дозволяють копіювати, переміщувати, перейменовувати та видаляти файли.

# Для використання цих функцій shutil, нам потрібно імпортувати їх.

# Імпортуючи, ми фактично імпортуємо модуль, який у цьому випадку буде використовуватися для копіювання, переміщення, перейменування та видалення. Це робиться за допомогою команди імпорту; щоразу при відкритті нової консолі, нам потрібно імпортувати необхідні для роботи модулі.

# Робимо це за допомогою наступної інструкції:
from cmath import e
from logging import root
import shutil

#Копіювання здійснюється так:

#shutil.copy(джерело, шлях призначення)

# У першому параметрі в дужках нам порібно вказати шлях до файлу, який ми хочемо скопіювати, а в другому – шлях до каталогу, в який ми хочемо вставити файл. Обидва параметри мають рядковий тип, що означає, що ми прописуємо їх в одинарних лапках.

#У цьому випадку шлях записується за допомогою двох обернених скісних рисок \\.

import shutil
shutil.copy('D:\\git\\public90\\python\\campster\\writing.txt', 'D:\\git\\public90\\python\\campster\\new_writing.txt')

#У той час як shutil.copy () копіює лише файл, shutil.copytree() копіює всю папку та будь-які інші папки або файли, які вона містить. При виклику shutil.copytree(джерело, шлях призначення) папка буде скопійована з вихідного шляху до шляху призначення.

#Переміщення і перейменування файлів і директорій


# Ми скопіювали файли і тепер займемося їх переміщенням. Переміщення файлів здійснюється аналогічно копіюванню:

# shutil.move(джерело, шлях призначення)

# Файл, що знаходиться за шляхом, вказаним у першому параметрі, буде переміщений до шляху, вказаному в другому параметрі. При виклику цієї функції буде повернуто шлях до нового місця розташування.

# Шлях до місця призначення також може містити ім'я файлу. У наступному прикладі вихідний файл переміщується та перейменовується:

shutil.move('D:\\git\\public90\\python\\campster\\new_writing.txt', 'D:\\git\\public90\\python\\new_writing_test_example.txt')

# Якщо ми вкажемо не існуючу папку в шляху перемещення файлу то файл кий ми переміщяємо буде переіменований на назву неіснуючої папки , тому треба уважно вводити шлях переміщення файлу  

# Видалення окремого файлу або порожнього каталогу може бути виконано шляхом імпорту модуля ОS, тоді як модуль shutil використовується для видалення папки та всього її вмісту.

# os.unlink(path) - Deleting the file path
# os.rmdir(path) - Deleting the folder on the path. The folder must be empty.
# shutil.rmtree(path) - Deleting the folder on the path, as well as all the files and subdirectories that are in it. 

# Оскільки вбудована функція Python shutil.rmtree() безповоротно видаляє файли та каталоги, її використання може бути небезпечним. Набагато кращим способом видалення файлів та каталогів є використання модуля send2trash. Цей модуль необхідно встановити, запустивши командний рядок на комп’ютері та задавши наступну команду:

# pip install send2trash

# Набагато безпечніше використовувати send2trash, ніж звичайні функції видалення Python, оскільки ця функція буде відправляти файли та каталоги в Кошик Вашого комп'ютера, а не видаляти їх назавжди.

# Якщо ми видалимо щось із програми помилково, використовуючи send2trash, пізніше ми зможемо відновити його з Кошика.

# Після встановлення модуля ми можемо повернутися до написання програми. Спочатку нам потрібно імпортувати send2trash, потім створити новий текстовий файл bacon.txt, написати щось у ньому, закрити його, а потім видалити:

import send2trash
baconFile= open('D:\\git\\public90\\python\\bacon.txt', 'a')
baconFile.write('Give PEACE!!!!')
baconFile.close()
send2trash.send2trash('D:\\git\\public90\\python\\bacon.txt') 
# Якщо після цього Ви відкриєте Кошик на Вашому комп’ютері, Ви знайдете в ньому файл bacon.txt, який ми видалили нещодавно.

# Взагалі радимо завжди використовувати функцію send2trash для видалення файлів та каталогів. Однак, відправка їх у Кошик не звільнить місця на диску, як це відбувається у випадку безповоротного видалення.
   
# Стиснення файлів: zipfile


# Напевно, Ви вже знайомі із ZIP файлами (з розширенням .zip), які можуть містити стиснутий вміст багатьох інших файлів. Стиснення даних зменшує розмір файлів, що стане у нагоді при їх відправці через Інтернет. ZIP файл може містити декілька папок та підпапок, тому це ефективний спосіб упаковки кількох речей в одну.
# Python може створювати та відкривати ZIP файли за допомогою функцій модуля zipfile. Скажімо, у нас є ZIP файл під назвою "example.zip" з наступною структурою каталогів:

#           [___]cats
#             |
#             |-[_] catnames.txt
#             |-[_] zophie.ipg
#           [_]spam.txt


# Створення ZIP файлів

# Для створення власного ZIP файлу нам необхідно активувати режим запису при створенні об'єкта ZipFile, тобто вказати другий аргумент як 'w'. Коли ми передамо шлях до методу write(), Python стисне файл за вказаним шляхом та додасть його до ZIP файлу. Перший аргумент методу write() – це рядок імен файлів, які потрібно додати. Другий аргумент – compress_type, який повідомляє комп’ютеру алгоритм, що буде використовуватися для стиснення файлів.

# Значення compress_type завжди можна задавати як zipfile.ZIP_DEFLATED.

# Такий тип стиснення добре працює для всіх типів даних.

import zipfile
newZip = zipfile.ZipFile('D:\\git\\public90\\python\\new.zip', 'w') #створюємо файл архіву
newZip.write('D:\\git\\public90\\python\\new_writing_test_example.txt', compress_type=zipfile.ZIP_DEFLATED) # вказуємо що(шлях до файлу) треба помістити в архів та алгоритм стискання
newZip.close()

# У цьому прикладі ми створюємо новий ZIP файл під назвою "D:\\git\\public90\\python\\new.zip", який містить стиснутий файл "D:\\git\\public90\\python\\new_writing_test_example.txt".

# Зауважте, що, як і під час запису в файл, режим 'w' видаляє весь поточний вміст ZIP файлу. Якщо Вам потрібно додати файл до існуючого ZIP файлу, передайте "a" як другий аргумент для ZipFile. ZipFile відкриє файл у режимі додавання запису.
f = open('D:\\git\\public90\\python\\new_writing_test_example.txt', 'a')
print('Це рядок 3.', file=f)
print('Це рядок 4.', file=f)
f.close()
# Тут текст буде введено в існуючий файл writing.txt, тому новий вміст додається до вже наявного тексту.

# Читання ZIP файлів
# Щоб прочитати вміст ZIP файлу, спочатку нам необхідно створити об'єкт ZipFile (у нашому прикладі це exampleZip) за допомогою функції zipfile.ZipFile(). Перший zipfile – це ім'я модуля Python, а другий ZipFile – це ім'я функції.


# Відкриття (extract) ZIP файлів
# Метод extractall() розархівовує всі файли та папки з ZIP файлу в каталог, в якому знаходиться програма.

import zipfile, os
os.chdir('D:\\git\\')# куди експортувати файл
exampleZip = zipfile.ZipFile('D:\\git\\public90\\python\\new.zip') # який файл будемо відкривати
exampleZip.extractall() #відкриваємо всі що є в архіві
exampleZip.close()
# Крім того, ми можемо передати ім'я папки в extractall(), щоб розархівувати файли в папку, що відсутня в поточному каталозі нашої програми. Якщо шлях, переданий методу extractall(), не існує, він буде створений.

# Метод extract() розархівовує окремі файли ZIP файлу.

exampleZip.extract('spam.txt')
exampleZip.extract('spam.txt', 'C:\\some\\new\\folders')
exampleZip.close()
# Рядок, який ми передаємо методу extract(), повинен збігатися з одним із рядків, що повертаються namelist(), наприклад, у нашому прикладі таким є spam.txt. Крім того, шлях, куди файл буде розархівовано, при умові, що він не є поточним каталогом, може вказуватися як другий аргумент. Якщо папка з другого аргументу не існує, Python створить її. Значення, що повертається extract() – це абсолютний шлях, за яким розархівовано файл.


#################### Що таке винятки?###################

# Одним із завдань програміста є усунення помилок. Python надає два способи обробки помилок:

# Обробка винятків
# Твердження. 
# Винятком є непередбачувана ситуація або подія, яка може виникнути при виконанні, тобто при інтерпретації програмного коду. "Обробка винятків" стосується подолання непередбачуваної ситуації в програмі з метою забезпечення регулярного завершення програми, якщо це можливо. В іншому випадку програма перестане працювати під час процедури обробки даних.

# Твердження або попередження – це прийоми, які використовуються для перевірки допустимості виразу, діапазону індексу, значень змінної тощо. Якщо перевірка не вдалася, Python викличе виняток AssertionError.

################Керування винятками за допомогою try/except#################

# Якщо Ви добре засвоїте наступні уроки, Вам не знадобиться жодна допомога. Давайте почнемо з обговорення помилок в Python.

# Наприклад, якщо ми напишемо програму, в якій в одному рядку коду у нас буде ділення a=b/c, і якщо так трапиться, що c=0, то станеться ділення на нуль і програма припинить свою роботу, вивівши повідомлення про помилку.

b=4
c=0
try:
	a=b/c
except ZeroDivisionError:
	print('Error!')

# Після цього на екрані з'явиться слово "Error!" і програма продовжить свою роботу.

# ZeroDivisionError завжди виникає при діленні на нуль, що є неприпустимим. Ви можете обробляти помилки за допомогою блоків "try" та "except". Частина коду, яка потенційно може містити помилку, поміщається в блок "try". При виникненні помилки виконання програми поновлюється командою "except".

# В блоці "try" можуть міститися численні команди, а також численні блоки "except", як показано в наступному прикладі:
try :
    a=eval(input('Введіть число:'))
    print(3/a)
except NameError:
    print('Будь ласка , ввeдіть число.')
except ZeroDivisionError:
    print('Агов!!!Не можна ділити на 0')

# Якщо після запуску цієї програми ми введемо якийсь текст або щось, що не є числом, з'явиться повідомлення про виняток NameError: "Будь ласка, введіть число". Якщо ми введемо 0, на екрані з'явиться повідомлення про виняток ZeroDivisionError: "Не можна вводити 0".

# Ось приклад використання try/except при роботі з файлами:
try:
    datoteka = open('D:\\git\\public90\\python\\campster\\database.txt', 'a')
    print("Hi everyone!!", file=datoteka) 
    datoteka.write("Текст для введення в базу даних!!") 
    datoteka.close()
except NameError:
      print ("Невідома база даних")
except IOError:
      print ("Помилка: не вдається записати текст в базу даних", datoteka)
else:
      print ("Текст успішно введено в базу даних", datoteka)

###########################Підняття винятків##############

# Python викликає винятки щоразу, коли намагається виконати неприпустимий код. На додачу до обробки винятків за допомогою блоку try/except ми також можемо викликати наші власні винятки в нашому коді.

# Винятки викликаються командою "raise". У коді команда "raise" представлена:

# Ключовим словом raise

# 1.викликом функції Exception()
# 2.рядком із повідомленням користувача про помилку, що передається функції Exception()

# Наприклад, якщо ми написали наступний рядок коду:
# raise Exception('Це повідомлення про помилку.')

# Отже, при відсутності блоків try та except на додачу до команди raise, яка зазвичай викликає винятки, програма просто аварійно завершить роботу та відобразить повідомлення про помилку.

# Часто код, який викликає функцію, а не сама функція, знає, як обробляти винятки. Таким чином, команда raise зазвичай знаходиться всередині функції, а блок try/except – всередині коду, який викликає функцію.

# Простий приклад використання raise:
if (a < b):
    raise ValueError()

##################### Твердження ######################

# Команда assert – це зручний спосіб задати в програмі умови, що стосуються правильності виконання програми. Це робиться для полегшення налагодження програм.

# Існує два типи команд assert:

# assert <умова>   
# assert <умова> , <повідомлення>  

# Умова є логічним виразом, тоді як повідомлення – це рядок, що буде відображатися. Ця команда працює таким чином, що нічого не відбудеться, якщо умова оцінюється як істинна, і тому програма продовжить роботу. Однак у випадку, якщо умова оцінюється як хибна, програма припинить роботу, викликавши повідомлення про помилку із рядка, який ми написали.

# Ось приклад. Припустимо, ми зберегли наведену нижче програму у файлі example.py:

def chkassert(num):
    assert type(num) == int
    return num**2

chkassert('a')

# Причиною виникнення помилки є те, що ми поміщаємо аргумент 'a' (рядок) всередині виклику функції chkassert, тому команда assert, перевіряючи тип аргументу, приходить до висновку, що тип не відповідає int, та повідомляє про помилку.

# Якби ми надіслали у функцію ціле число, про помилку не було б повідомлено. Натомість функція повернула б квадрат числа.

######Вступ до об'єктно-орієнтованого програмування########
# Швидше за все, Ви чули про об'єктно-орієнтоване програмування, хоча, можливо, не впевнені, що це таке. Щоб краще його розуміти, необхідно засвоїти наступні терміни: об'єкти, класи, методи, інтерфейси та пакет. Всі вони очікують на Вас на цьому рівні, тому ми почнемо з самого початку. Що таке об'єктно-орієнтоване програмування та який підхід воно передбачає?

# Python – це об'єктно-орієнтована мова, тому написання програм мовою Python вимагає знання основних термінів, пов'язаних з об'єктно-орієнтованим програмуванням, таких як об'єкти та класи.

#Об'єктно-орієнтований підхід до програмування базується на маніпулюванні об'єктами.

# Це означає, що розвиток логіки програми досягається шляхом визначення класів різних об'єктів та використовуючи взаємодію об'єктів.

# Ключовий термін тут "об’єкт". Об'єкт складається з двох елементів: даних і функцій (які називаються методами), що працюють з даними. Наприклад, об'єкти – це рядки, а дані – літери, з яких складається рядок. Це стосується не лише рядків, а й цілих чисел, десяткових чисел та навіть функцій.

####Об'єкти і класи#####

#Об'єкт або екземпляр(Зразок чогось, створений за певним шаблоном (класом).) – це зразок чогось, створений за певним шаблоном, тобто згідно певного класу(Загальне представлення сукупності об'єктів (предметів або подій) з однаковою структурою та поведінкою.). Приведемо приклад з реального життя.

# Нехай для прикладу у нас буде клас "Автомобіль". Об'єктами, тобто зразками цього класу є Фіат, Тойота, Опель тощо. Чи є літак екземпляром класу Автомобіль? Звичайно, що ні, але автомобіль та літак можуть бути екземплярами класу Транспортний Засіб. Отже, клас – це шаблон, відповідно до якого створюються об'єкти.

# Уявіть креслення будівлі та будівлю, побудовану на основі цього креслення. Креслення будівлі представляє собою клас, а сама будівля є об’єктом, побудованим на основі цього класу. Крім того, можна створити декілька будівель на основі одного креслення, так само, як можна на основі одного класу побудувати кілька об'єктів цього класу.


################Створення класів та об’єктів###############

#Клас містить код для всіх методів об'єктів цього класу. Зараз ми звернемося до простого прикладу, щоб показати, як виглядає клас:
class Primer:
    def __init__(self,a,b):
        self.a=a
        self.b=b

    def add(self):
        return self.a + self.b

e = Primer(8,6)
print(e.add())

# Як ми бачимо, для створення нового класу використовується команда class. Назва класу зазвичай починається з великої літери.

# Для створення нового об'єкта класу ми просто викликаємо ім'я класу разом із його значеннями, які ми хочемо передати конструктору (це буде обговорюватися більш докладно на наступному уроці). Зазвичай ми присвоюємо об'єкт змінній; це відбувається у рядку e=Example(8, 6), де новостворений об’єкт присвоюється змінній e. Для використання об'єкта використовується оператор ., як у e.add().

########################Члени класу#######################
#Як ми вже говорили, клас – це загальне представлення сукупності об'єктів (предметів або подій) з однаковою структурою та поведінкою. Клас представляє собою спрощене відображення реальних предметів і подій, та складається з:



# характеристик (атрибутів)
# поведінок (методів)
# відносин з іншими класами
# Атрибути, методи та відносини називаються елементами (членами) класу.




# Атрибути представляють деякі характеристики (особливості) класів. Вони зберігають значення, важливі для елемента, який ми описуємо. Наприклад, для класу Автомобіль атрибутами є марка, максимальна швидкість, колір тощо.



# Операції над об'єктами визначаються у функціях та називаються "методами" об'єктів. Методи – це дії, які ми виконуємо над елементами. У нашому прикладі це може бути включення двигуна, додавання газу, натискання на гальма тощо. Синтаксис методу об'єкта виглядає як object.method().

# Приклад класів Python:

# Клас String

#1. атрибути: послідовність символів, що знаходяться в рядку
#2. методи: upper(), replace(), split()… 

# # Список 

#1. атрибути: члени списку
#2. методи: append(), sort()…

######Конструктори######

# У більшості класів є метод під назвою __init__. Підкреслення вказують на те, що це особливий тип методу. Цей метод називається конструктором та автоматично викликається, коли ми створюємо об'єкт цього класу. Конструктор зазвичай використовується для присвоєння початкових значень змінним класу.

                # Спеціальні методи часто називають магічними методами. Вони по-різному інтерпретуються інтерпретатором Python і мають особливу семантику. Формат імені __xyz__.


class Example:
    def __init__(self, a,b):
        self.a=a
        self.b=b
    
    def add(self):
        return self.a+self.b

e= Example (100,6)
print(e.add())
        
# У цьому прикладі конструктор приймає два значення "a" та "b" і присвоює їх змінним класу self.a та self.b. Перший аргумент "кожного" нашого методу класу – це спеціальна змінна, яка називається "self". Щоразу, коли ми викликаємо змінні чи методи із класу, ми повинні додавати слово "self" перед їхніми іменами. Слово "self" – це те, що фактично відокремлює змінну від методу в класі, а також інші змінні від інших методів, присутніх у програмі.

# Таким чином, конструктор - це метод, який активується автоматично при створенні екземпляра класу. Наприклад, якщо у нас є клас "Будинок", то в конструкторі ми можемо зробити дах червоним. Щоразу, коли створюється новий екземпляр класу Будинок, дах автоматично стає червоним, тому що саме так визначено в конструкторі.

########Успадкування (Наслідування)###########

# В об'єктно-орієнтованому програмуванні існує концепція, яка називається наслідуванням, і вона передбачає створення класу на основі вже існуючого класу. Наслідування представляє собою особливість класу приймати характеристики інших класів, при чому:

            # Клас, що успадковується, має статус батьківського або базового класу

            # Клас, що успадковує, має статус дочірнього класу


# При цьому, новий клас отримує всі змінні та методи класу, який він успадковує. У новостворений клас ми можемо додавати нові змінні та методи, яких до цього не було в базовому класі, а також перевизначати деякі методи з базового класу.

# Реалізація наслідування від декількох класів одночасно також можлива, але може виявитися, що зробити це не надто просто.

# Ось приклад:

class Parent:
    def __init__(self, a):
        self.a=a
    def method1(self):
        print(self.a*2)
    def method2(self):
        print(self.a+'!!!!')

class Child(Parent):
    def __init__(self,a,b):
        self.a=a
        self.b=b
    def method1(self):
        print(self.a*7)
    def method3(self):
        print(self.a + self.b)

p=Parent('hi')
c=Child('hi','bye')

print('Parent method1:',p.method1())
print('Parent method2:', p.method2())
print()
print('Child method1', c.method1())
print('Child method2', c.method2())
print('Child method3', c.method3())

# Результатом буде:
                # Parent method 1: hihi
                # Parent method 2: hi!!!

                # Child method 1: hihihihihihihi
                # Child method 2: hi!!!
                # Child method 3: hibye


# Розглядаючи цей приклад, ми можемо помітити, що клас "Child" перевизначив method1 класу "Parent", внаслідок чого рядок відображався класом "Child" сім разів, а не два, як це було перед перевизначенням. Клас "Child" успадкував method2 від класу "Parent", тому нам не потрібно визначати його ще раз. Клас "Child" додає нову змінну b та новий метод method3.

                # При наслідуванні класу базовий клас поміщається в дужки в команді class.



#####################Поліморфізм#######################

# Ми часто говоримо, що базовий клас визначає загальний інтерфейс, який міститиме всі класи, що успадковують базовий клас. Ці класи, які успадковують базовий клас, можуть визначати власну реалізацію цього інтерфейсу.

                    # Поліморфізм у Python визначається як здатність використовувати об'єкт підкласу як тип параметра суперкласу.

# Наприклад, типи об'єктів "Коло" та "Прямокутник" можуть використовуватися у функціях, які очікують типи об'єктів "ГеометричніФігури".

# Для використання поліморфізму ми створимо два окремі класи, які будемо використовувати з двома різними об'єктами. Кожен з цих різних класів повинен мати спільний для них обох інтерфейс, щоб їх можна було використовувати поліморфно. Далі ми додамо до цих класів методи, які відрізняються, але мають однакове ім'я.

# Створюємо класи "Shark" та "Clownfish", які обидва будуть визначати методи swim(), swim_backwards() та skeleton().
class Shark():
    def swim(self):
        print('The shark is swimming.')
    
    def swim_backwards(self):
        print('The shark cannot swim backwards, but can sink backwards.')

    def skeleton(self):
        print("The shark's skeleton is made of cartilage")

class Clownfish():
    def swim(self):
        print("The clownfish is swimming.")
    
    def swim_backwards(self):
        print("The clownfish can swim backwards.")

    def skeleton(self):
        print("The clownfish's skeleton is made of bone.")

# У цьому прикладі класи Shark та Clownfish містять три методи з однаковими іменами. Однак функціональність цих методів різна для кожного класу. Ми створимо два об'єкти, один для класу Shark, а інший для класу Clownfish:
    
sammy=Shark()
sammy.skeleton()
            # The shark's skeleton is made of cartilage
casey=Clownfish()
casey.skeleton()  
             # The clownfish's skeleton is made of bone.


#################Базові концепції#####################

# Досі єдиними способами комунікації між програмами і користувачами були клавіатура та команда введення даних. Більшість програм сьогодні використовують вікна, кнопки, прокрутку та багато інших візуальних елементів. Ці так звані віджети є частиною Графічного інтерфейсу користувача (Graphical User Interface, скорочено GUI). Цей рівень стосується програмування GUI та використання модуля Tkinter. Кожна програма GUI, яку ми захочемо написати, складатиметься з трьох рядків коду:

from tkinter import*
root= Tk()
mainloop()

# Ми імпортували всі елементи GUI з модуля Tkinter у перший рядок. Другий рядок використовується для створення вікна на екрані, яке ми назвемо root (або будь-яким іншим ім’ям, яке ми вирішимо йому дати). Третій рядок використовується для розмішення в програмі нескінченного циклу while, який називається "циклом очікування події". Принцип його роботи полягає в очікуванні натискання клавіші клавіатури або кнопки миші, поки користувач не закриє вікно.

from tkinter import*
def change():
   entry=int(entry.get()) 
   entry=
   output_lablel.configure(text='Дохід від  вбитих москалів:{:1f} $'.format(entry))
   entry.delete(0,END)

root = Tk()
message_lable=Label(text='Введіть кількість убитих москалів ', font=('Vernada',16))
output_lablel=Label(font=('Vernada',22))
entry=Entry(font=('Vernada',22), width=4)
calc_button=Button(text='Натиснути', font=('Vernada', 18), command=change)
message_lable.grid(row=0,column=0)
entry.grid(row=0,column=1)
calc_button.grid(row=0,column=2)
output_lablel.grid(row=1, column=0,columnspan=3)
mainloop()

###############Написи################

# Мітка – це місце, де наша програма виводить текст на екран. Наступним її кроком є створення таблиці та збереження її у певному місці на екрані.

 hello_label = Label(text='hello')
 hello_label.grid(row=0, column=0)
# Як ми бачимо, функція Label() використовується для створення міток. Ми використовуємо метод grid для розміщення міток на екрані. Метод розглядає екран як прямокутник, що складається з рядків і стовпців. Першими кількома рядками та стовпцями є 

# (row=0, column=0)   (row=0, column=1)   (row=0, column=2)
# (row=1, column=0)   (row=1, column=1)   (row=1, column=2)
# (row=2, column=0)   (row=2, column=1)   (row=2, column=2)

# Ми можемо використовувати численні параметри, такі як розмір шрифту, кольори тощо.

hello_label = Label(text='hello', font=('Verdana', 24, 'bold'), bg='blue', fg='white')
# У випадку з функцією Label ми використовуємо ключові слова для різних параметрів. Ми перерахуємо деякі з них, які часто використовуються:

# font: основна структура для параметру шрифт – це font=(назва шрифту, розмір шрифту, стиль). Ви можете опустити розмір і стиль шрифту, якщо хочете. Параметри стилю ‘bold’, ‘italic’, ‘underline’, ‘overstrike’, ‘roman’ та ‘normal’ (опція за замовчуванням). Можна комбінувати кілька стилів, наприклад: ‘bold italic’.
# fg and bg: – ці параметри призначені для кольорів переднього плану та фону. Ви можете використовувати звичайні назви кольорів, такі як ‘blue’, ’green’ тощо. Ви також можете скористатися виразами для кольорів, наприклад: "#A202FF", які можна використовувати, щоб задати будь-який колір.
# width: використовується для зазначення кількості знаків (символів), які може містити мітка. Якщо не задати цей параметр, Tkinter автоматично визначить її як ту кількість знаків, яку ви спочатку помістили в текст мітки. Це може призвести до несподіваних результатів, тому краще заздалегідь вказати довжину тексту в мітці.
# height: використовується для зазначення кількості рядків, які міститиме ваша мітка. Так створюються багаторядкові мітки. Використовуйте спеціальний знак нового рядка (\n) під час написання тексту мітки. Наприклад, text=’hi\nthere’.
# activebackground: який колір фону використовувати, коли мітка активна.
# anchor: визначає, де в мітці повинен бути розміщений текст (або зображення). Використовуйте такі значення: N, NE, E, SE, S, SW, W, NW або CENTER. Значення за замовчуванням – CENTER.
# background: колір фону.
# cursor: який курсор відображається, коли курсор миші знаходиться над позначкою.
# highlightbackground: який колір використовується для підсвічування рамки, коли віджет не у фокусі.
# highlightcolor: який колір використовується для підсвічування рамки, коли віджет знаходиться у фокусі.
# image: зображення, яке буде відображатися у віджеті. Можливі значення: PhotoImage, BitmapImage тощо.
# justify: визначає спосіб вирівнювання декількох рядків тексту. Використовуються значення LEFT, RIGHT чи CENTER. Значення за замовчуванням – CENTER.
# text: текст, який буде відображатися в мітці.
# underline: використовується з параметром text, щоб вказати, що текст має бути підкреслений.
# Зміна параметрів
# Згодом після створення мітки ми, ймовірно, захочемо щось змінити в програмі. Для цього нам знадобиться метод configure.

label.configure(text='Bye')	
label.configure(bg='white', fg='black')
# Щоразу, коли ми створюємо новий віджет, для того, щоб помістити його на екран, ми повинні використовувати grid, інакше він не буде відображатися на екрані.


#################Поле введення##########
# За допомогою поля введення GUI допускає введення тексту. Наступний приклад демонструє, як створюється поле введення:

entry = Entry()
entry.grid(row=0, column=0)

                # Ми використовуємо grid для розміщення поля введення та інших елементів на екрані.

# Щоб отримати текст з поля введення, ми використовуємо функцію "get". За замовчуванням ця функція повертає рядок, і якщо нам потрібні числові дані, ми можемо скористатися функцією eval або int, float. Тепер наведемо простий приклад отримання даних з поля введення, яке ми назвали entry:
string_value = entry.get()
num_value = eval(entry.get())

#########################Поле введення###################
#########################Поле введення###################
# За допомогою поля введення GUI допускає введення тексту. Наступний приклад демонструє, як створюється поле введення:
entry = Entry()
entry.grid(row=0, column=0)

# Ми використовуємо grid для розміщення поля введення та інших елементів на екрані.

# Щоб отримати текст з поля введення, ми використовуємо функцію "get". За замовчуванням ця функція повертає рядок, і якщо нам потрібні числові дані, ми можемо скористатися функцією eval або int, float. Тепер наведемо простий приклад отримання даних з поля введення, яке ми назвали entry:

string_value = entry.get()
num_value = eval(entry.get())

# Якщо нам потрібно видалити текст з цього поля, ми можемо зробити це в такий спосіб:
entry.delete(0,END)

# Для введення тексту в поле ми використовуємо:
entry.insert(0, 'hello')
#############################Зображення######################
# Мітки, кнопки та інші віджети можуть відображати зображення замість тексту. Використання зображень вимагає трохи підготовки. Спочатку нам потрібно створити об’єкт PhotoImage та дати йому ім’я:

cheetah_image = PhotoImage(file='cheetahs.gif')
# Тепер ми відобразимо зображення у віджетах:

label = Label(image=cheetah_image)
button = Button(image=cheetah_image, command=cheetah_callback())
               # Одним із обмежень Tkinter є те, що можна використовувати лише зображення GIF. Якщо Ви хочете використовувати деякі інші типи файлів, одним із рішень є використання бібліотеки Python Imaging Library, за допомогою якої Ви можете конвертувати інші формати зображень у GIF.


###########################
# У цьому курсі нам залишається розглянути лише Canvas. Віджет Canvas (Полотно) – це область, на якій можна малювати лінії, кола, прямокутники. Тут також можна малювати текст, відображати зображення та інші віджети. Це надзвичайно практичний віджет і ми випробуємо його основні можливості.

# За допомогою наступного рядка коду ми створимо полотно з білим фоном та задамо його розміри як 200 x 200 пікселів:

canvas = Canvas(width=200, height=200, bg='white')
# Намалюємо прямокутник на полотні за допомогою наступного рядка коду:

canvas.create_rectangle(20,100,30,150, fill='red')
# Перші чотири аргументи стосуються координат прямокутника на полотні. Лівий верхній кут полотна має координати (0,0), а лівий верхній та нижній правий кути прямокутника мають відповідно координати (20, 100) та (30, 150). Якби ми випустили параметр fill = 'red', у прямокутника за замовчуванням була б чорна рамка.

# Малюємо еліпси та лінії наступним чином:

canvas.create_rectangle(20,100,70,180)
canvas.create_oval(20,100,70,180, fill='blue')
canvas.create_line(20,100,70,180, fill='green')
Робота з прямокутниками, лініями та овалами аналогічна.

# Перші дві координати стосуються верхнього лівого кута, а решта дві – нижнього правого.

# Якщо нам потрібно відобразити коло з радіусом r та центром u (x, z), використовуємо таку функцію:

def create_circle(x,y,r):
        canvas.create_oval(x-r,y-r,x+r,y+r)
# Також ми можемо додавати зображення до полотна:

cheetah_image = PhotoImage(file='cheetahs.gif')
canvas.create_image(50,50, image=cheetah_image)
# Дві координати вказують, де знаходиться центр зображення:

# Ви досягли кінця цього курсу. Перевірте свої знання ще раз. Бажаємо Вам великих успіхів у роботі з Python!







