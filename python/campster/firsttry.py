# Це коментар
import re
from time import sleep


number = 3 #Змінній number було присвоєно значення 3м
print ('The value of the varuable number is ', number) 
#name=  input ('What is your name?')  
message= 'Hi everyone, how are you?'
#len(message) 
print('the message have', len(message), 'letters')
# Коли нам потрібно перетворити ціле число в одному рядку коду в рядок, ми використовуємо функцію "str()". Наприклад:
number= str(123)
print(number)
#Таким чином, немає жодної різниці між записом "str(123)" та записом "123".
#int() Ця функція робить щось подібне. Вона перетворює переданий їй рядок у ціле число.
newNumber = int('234')
print(newNumber)
# float()
#Як Ви могли здогадатися, ця функція перетворює рядок у форму з плаваючою комою.
number = float('123.4')
print(number)
# оператори використовуються для математичних операцій, таких як додавання, віднімання, множення, ділення тощо.
x = 15
y = 4
# Output: x + y = 19
print('x + y =',x+y)
# Output: x - y = 11
print('x - y =',x-y)

# Output: x * y = 60
print('x * y =',x*y)

# Output: x / y = 3.75
print('x / y =',x/y)

# Output: x // y = 3
print('x // y =',x//y)

# Output: x ** y = 50625
print('x ** y =',x**y)
# "Логічними операторами" є: and, or, та not.
x = True
y = False
# Output: x and y is False
print('x and y', x and y)
# Output: x or y is True
print('x or y is',x or y)
# Output: not x is False
print('not x is',not x)
# "Оператори порівняння", як випливає з їх назви, використовуються для порівняння значень; вони оцінюють, чи є твердження істинним або хибним.
x = 10
y = 12

# Output: x > y is False
print('x > y  is',x>y)

# Output: x == y is True
print('x == y  is',x==y)

# Output: x >= y is True
print('x >= y is',x>=y)

#"Оператори присвоювання" використовуються для присвоєння значень змінним. Ми вже знайомі з найпростішим оператором: x=5, де значення 5 присвоюється змінній x.

#Існують також різні складні оператори, наприклад, а+=5, що додає значення 5 до значення змінної a, і потім це нове значення присвоюється змінній a. Тобто він еквівалентний виразу a=a+5.

#Часто нам потрібно, щоб програма щось робила, але лише тоді, коли щось інше є істинним або хибним. У таких випадках ми використовуємо оператор if.
#Тепер давайте подивимося, для чого використовується оператор else. Якщо твердження if не виконується, весь код оператора if ігнорується і виконується лише тіло оператора else. Таким чином, після ключового слова "else" ми задаємо код, який виконується лише в тому випадку, якщо умова if не була виконана.
if (7<6):
    print('This is true')
else:
    print('7 more than 6')

#У прикладі, де ми використовуємо індивідуальні оператори if, кожна умова перевіряється незалежно від того, чи це потрібно. Наприклад, якщо значення змінної становить 96, програма виведе "Відмінно", але продовжить перевіряти умови для 9, 8, 7..., що не дуже ефективно. Проте, використовуючи "оператор elif", програма припиняє перевіряти всі інші умови в блоці, як тільки одна з умов буде виконана.
points= eval(input('Введіть кількість балів:'))

if points>=90:
    print('Відмінно')
elif points>=80:
    print('Добре') 
elif points>=70:
    print('Непогано')
elif points>=60:
    print('Задовільно')
else :
    print('Незадовільно')
#Функція eval дозволяє програмі python запускати код python у собі. Додайте будь який вираз для перевірки 
a= input("Введіть вираз що хочете поррахувати:  ")
print (eval(a))

# Петля for Коли програма запускається, вона встановлює змінну i як 0. При кожному поверненні до початку циклу, змінна i збільшується на 1. Так повторюється 10 разів і кожного разу змінна збільшується на 1, поки цикл не здійснить 10 ітерацій. У цей момент змінна має значення 9.
for j in range(10):
    print('God!Please Stop war !!!')
#Ця програма просить користувача ввести число, після чого виводить квадрат цього числа та повторює процес тричі:
for k in range(3):
    number= eval(input('Enter number:'))
    print('Квадрат вашого числа це', number**2)
#Функція range 
#Значення, яке ми записуємо у функцію range, визначає, скільки разів цикл повториться. Функція range працює наступним чином: вона генерує послідовність чисел, від нуля до числа, введеного нами у функцію мінус один. Отже, range(5) генерує таку послідовність: 0, 1, 2, 3, i 4.

#Якщо нам потрібно, щоб список чисел починався зі значення, відмінного від нуля, ми можемо досягти цього, вказавши це число в функції "range"
#Інший варіант полягає в тому, що список збільшується не на 1, а на інше обране нами число. Розглянемо такий приклад:
#           range(1,5) згенерує список 1, 2, 3, 4.
#За допомогою команди range(1, 10, 2) буде створено список "1, 3, 5, 7, 9". Як можна здогадатися, список починається з числа 1 (перший параметр) і доходить до числа 10 (другий параметр), причому кожне значення збільшується на 2 (третій параметр).
#Структура циклу
                #for variable_name in range(кількість_повторів):
                #команди, які потрібно повторити
for j in range(166000,169500,500):
    print(j,'Вбитих москалів!!!)')
    sleep(1)
#бувають ситуації, коли ми не знаємо заздалегідь, скільки ітерацій буде виконано. У цих ситуаціях використовувати лічильник циклу немає сенсу, оскільки умова виходу з циклу залежить не від значення лічильника, а від іншої умови. Цикл while створено саме для таких типів ситуацій.
                        #while умова:
                        #тіло циклу while
# Приклад друку чисел від 1 до 10:
a=0
while a<10:
    print(a)
    sleep(1)
    a=a+1
    
# Що насправді тут відбулось? Спочатку змінна "a" має значення 0. Після входу в цикл while (коли a менше 10) це значення збільшується на 1 та виводиться на екран. Це продовжується, поки "a" не досягне 10.

#Break
#"Оператор break" використовується для завершення циклів "for" або "while" до їхнього закінчення.
#Ця програма дозволяє користувачеві ввести 10 чисел. Однак користувач може достроково її припинити, ввівши від'ємне число:
for k in range(3):
    num = eval(input('Треба ввести число :'))
    if num < 0:
        break

for val in "string":
    if val == "i":
        break
    print(val)
#У цьому прикладі "цикл for" перевіряє літеру за літерою. Він починає з "s" і перевіряє, чи одна з них "i". Якщо це не так, літера виводиться ("друкується"). Після потрапляння на букву "i" команда "break" перериває "цикл for", і тому виводяться лише букви перед "i": s, t, r.

#Continue
#"Оператор continue" негайно переходить до наступної ітерації циклу та припиняє виконання поточної ітерації.
for val in "string":
    if val == "i":
        continue
    print(val)

#Як можна бачити, у цьому прикладі на відміну від попереднього, коли ми дійшли до літери "i", цикл for не зупинився, а продовжував друкувати слово до кінця без цієї літери. Це єдина різниця між операторами "break" та "continue".

# Функції використовуються для розбиття великих програм на менші частини, роблячи програму більш читабельною. Вони також стануть у нагоді, коли нам доведеться повторювати один і той же код у різних частинах нашої програми. Ми можемо помістити повторюваний код у функцію і викликати її щоразу, коли потрібно виконати команди з цього коду. Функції також можна використовувати для створення допоміжних функцій, математичних функцій тощо.

#Функції визначаються за допомогою ключового слова "def". Команда закінчується двокрапкою і в наступному рядку записується код, який є частиною функції.

def print_word():
    print('Доброго вечора ми з України !')
print_word() 
# Наша функція з попереднього прикладу не мала аргументів (дужки після імені функції були порожніми). Тепер у нас аналогічна функція з одним аргументом:
def print_word(n):
    print('Доброго вечора ми з України !!! Вам пізда москалі!!!'*n)
    print()
print_word(5)
#Значення, яке ми присвоюємо змінній "n", показує, скільки разів буде написано 'Доброго вечора ми з України !!! Вам пізда москалі!!!'

#Ми можемо одночасно передати функції декілька аргументів.

def write(string, b ):
    print(string*b)
    print()

write ("Свинособаки!!!" , 6)

#Як виглядають функції, що проводять розрахунки та повертають відповідний результат? Ознайомтесь з прикладом простої програми, яка перетворює метри в сантиметри:
def convert(m):
    return m*100
    
convert(2)
#Аргументи функції можуть мати значення за замовчуванням. Це значення є необов’язковим, тому, якщо інше значення не буде присвоєно такому аргументу при виклику функції, код функції буде використовувати значення за замовчуванням. Наприклад:
def print_func(string, n=2):
	print (string * n)
	print()
print_func('rerer!!!', 5)
#Отже, якщо ми не задамо другий аргумент, дане слово буде написано двічі, оскільки ми вказали це при визначенні функції.

#          def fancy_print(text, color, background, style, justify):

#Кожного разу, коли ми викликаємо цю функцію (зараз нам не дуже важливо, що вона робить, ми просто розглядаємо сигнатуру функції), нам потрібно знати правильний порядок аргументів. Так, ми спочатку задамо текстове значення, потім колір, фон, стиль та вирівнювання. Однак Python дозволяє нам іменувати аргументи при виклику функції, як показано у наступних прикладах:

# fancy_print(text='Hi', color='yellow', background='black', #style='bold', justify='left')

#fancy_print(text='Hi', style='bold', justify='left',background='black', color='yellow'

#Порядок аргументів у цьому випадку не важливий, оскільки ми використовуємо іменовані аргументи (імена аргументів).
#При визначенні функції рекомендується призначати аргументам значення за замовчуванням.
