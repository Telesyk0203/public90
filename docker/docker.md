## Встановлення Docker на Ubuntu
__https://docs.docker.com/engine/install/ubuntu/__

__https://rotoro-cloud.github.io/LabDock1num1/__ -тренування з docker <br>
### Створенння docker jenkins на основі alpine
1.проброс портів з контейнеру на хостовий інтерфейс<br> 
2.закріплення зберігання даних з контейнеру на хостовій пам'яті <br>
3. уточнення який юзер може запускати образ<br>
4. вибір образу для завантаження   
`docker run  -p 8080:8080 -v /home/ts90/DATA/jenkins/:/var/jenkins_home -u root jenkins/jenkins:lts-alpine`
<br>
___
5.також можна вказати параметр -d для прихованого (фонового) режиму . 
run - уже знакомая команда. она создает и запускает контейнер

pull - команда закачивает образ из репозитория на наш компьютер. run вызывает эту функцию, если контейнер не скачан.

ps - просмотр запущенных контейнеров

rm - удаление контейнера. Не образа, а именно контейнера

stop - остановить запущенный контейнер

start - запустить остановленный контейнер

exec - выполнить команду в запущенном контейнере

cp - копирование файлов между контейнером и хост-системой.

info - информация о состоянии и конфигурации контейнера

logs - логи контейнера

attach - зацепиться в консоль контейнера

search - поиск образа в репозитории

Команда run.

Чуть выше уже был пример ее использования. Продолжим =).

Чтобы запустить контейнер и оказаться в нем нам потребуются два флага

-t  подключение к консоли tty

-i  интерактивный режим

Выполняй
```
docker run -it  ubuntu bash 
```
и попадешь в консоль свежезапущенного контейнера  (выйти оттуда можно по команде exit)
___

+ Вот потыкал ты команды в консоли. Но это опять не то. Вот бы запустить контейнер так, чтобы он работал в фоновом режиме!

И это тоже можно. Для этого существует флаг -d (detached mode)
```
 docker run -d  -it ubuntu
```
Команда выполнилась и мы опять в консоле. Получилось или нет? Пока непонятно.

Непонятный набор символов, который вывелся на экран это идентификатор свежесобранного контейнера. Если пройти по пути /var/lib/docker/этот_набор_символов  можно увидеть рабочие файлы докера относительно этого контейнера. Т.к. это первый обзорный урок, то останавливаться на этом не будем. Рассмотрим внутренности докера позднее.

Чтобы увидеть список запущенных контейнеров надо ввести вот такую команду:
```
 docker ps
```
 ___

Узнать весь список можно вот так:
```
 docker ps -a
```
Все эти контейнеры хранятся на диске, пока их не удалят или не используют вновь.
___

А для чистки надо вывести только незапущенные.

Это делается флагом -f. Через этот флаг задается фильтр. Чтобы вывести только потушенные контейнеры, используется такая команда
```
 docker ps -a -f status=exited
```
 ___

 И вот у нас уже список только выключенных контейнеров. Можно брать по очереди id контейнеров и выполять

 docker rm 

Но это ж сколько ручной работы.... хотелось бы как-то одной командой все решить. Даже если отфильтровать вывод с помощью grep и awk, а потом по очереди всем id сделать rm в цикле. то это уже целый скрипт получается. Громоздко.

Но выход есть =)

Флаг -q выведет только id контейнеров. И в этом случае можно одной командой все подчистить:
```
 docker rm $(docker ps -a -q -f status=exited)
```
___
Создаем ветку (команды нужно делать в папке, в которую скачался репозиторий после git clone, обычно это название репозитория)
```
git checkout -b dev 
```
git checkout -b <имяветки> является шорткатом для git branch <имяветки> (cоздание новой ветки из текущей) за которым идет git checkout <имяветки> (переключение на эту ветку)
___
Давай создадим файл в директории с репозиторием и запушим его. 

Напомню, что файл должен быть создан в папке, в которую скачался репозиторий. У меня это devops_lesson_trial.
```
echo "Это просто текст" > justfile
```
___
Теперь добавляем файл в репозиторий
```
 git add justfile 
```
```
 git commit -m "Добавили простой файл. Просто так." 
```
Ты увидишь требование указать свои данные. Это нормально. Просто следуй предложенным инструкциям и повтори после этого коммит.
___
 Осталось только залить все наши измеения в github. Обычно это была бы команда git push, но так как мы создали новую ветку, которой не было в репозитории, нужно пушить так


```
git push --set-upstream origin dev 
```
___
Теперь поднимем контейнер из этого образа. 

--name тут задаем имя контейнера

-p тут указываем что 80 порт контейнера проброшен в 80 порт хоста

-d запуск контейнера в фоновом режиме (чтобы он не остановился сразу после запуска). 


```
docker run --name site -p 80:80 -d nginx
```


После этого мы можем видеть наш контейнер в выводе 
```
docker ps
```
___
Создаем внутри контейнера папку для нашего сайта и накидываем права.
```
docker exec -it site mkdir /var/www
```
```
docker exec -it site chown nginx:nginx /var/www
```
___
Теперь копируем файлы сайта из директории git в контейнер. 
```
docker cp /home/yodo/devops_lesson_trial/landing/. site:/var/www/
```
Заметь что недостаточно указать папку, чтобы докер скопировал все что в ней. 

Нужно указывать с точкой в конце:

/var/dir/. 
___
Не будем сейчас заморачиваться с настройками, создай site.conf у себя на виртуальной машине с таким содержанием:
```
server {

    server_name ip.your.vm.xx;

    access_log /var/log/nginx_access.log;

    error_log /var/log/nginx_error.log;

    root /var/www;

    location / {

                index  index.html index.htm index.php;

    }

}
```

Не забудь подставить адрес своей виртуальной машины. Скопируй этот файл в /etc/nginx/conf.d/ используя пример команды, которой мы только что скопировали сам сайт. 

После этого перезапустим контейнер 
```
docker restart site
```
После этого если зайти по адресу твоей ВМ, ты долежн увидеть сайт. 
___
Конструкция, которая нам поможет называется Dockerfile.

Он содержит инструкции по созданию образа. С них, набранных заглавными буквами, начинаются строки этого файла. После инструкций идут их аргументы. Инструкции, при сборке образа, обрабатываются сверху вниз.

Dockerfile может быть чрезвычайно простым и коротким. Например — таким:

FROM ubuntu:18.04

Dockerfile должен начинаться с инструкции FROM, или с инструкции ARG, за которой идёт инструкция FROM.

FROM - сообщает, что создаваемый образ базируется на базовом образе, в примере это ubuntu 18.04.

Когда вышеописанный Dockerfile используется на локальной машине для сборки образа в первый раз, Docker загрузит слои, определяемые образом ubuntu. Их можно представить наложенными друг на друга. Каждый следующий слой представляет собой файл, описывающий отличия образа в сравнении с тем его состоянием, в котором он был после добавления в него предыдущего слоя.

___
